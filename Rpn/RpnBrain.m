//
//  RpnBrain.m
//  Rpn
//
//  Created by athony on 5/29/13.
//  Copyright (c) 2013 __MyCompanyName__. All rights reserved.
//

#import "RpnBrain.h"

@interface RpnBrain()
@property (nonatomic, strong) NSMutableArray *programStack; 
@end


@implementation RpnBrain

@synthesize programStack = _programStack; 


/** Instance method: programStack
 * ------------------------------
 * programStack is the getter for the _programStack instance variable
 * programStack overrides the getter that is auto-generated by @synthesize. 
 * programStack has responsibility for instantiating an NSMutableArray 
 * (lazy instantiation).
 */ 

- (NSMutableArray*)programStack
{ 
    if(_programStack == nil) _programStack = [[NSMutableArray alloc] init];  
    return _programStack; 
}


/** Instance method: pushOperand
 * -----------------------------
 * self-documenting
 */ 

- (void)pushOperand:(double)operand
{
    [self.programStack addObject:[NSNumber numberWithDouble:operand]]; 
 
}


/** Instance method: pushVariable
 * -----------------------------
 * self-documenting
 */ 

- (void)pushVariable:(NSString*)variable
{
    [self.programStack addObject:variable]; 
    
}


/** Instance method: removeLastItem
 * -----------------------------
 * self-documenting
 */ 


- (void)removeLastItem
{
    /** safety check: validate that the stack holds at least 1 object before calling 
     *  removeLastObject
     */  
    id obj = [self.programStack lastObject]; 
    if(obj) [self.programStack removeLastObject]; 
}

/** Instance method: performOperation valParam
 * ----------------------------------
 * performOperation takes an NSString (that represents an operator) and a 
 * NSDictionary of variable/value pairs and returns the value of the program 
 * currently stored in the _programStack.
 */ 
 
- (double)performOperation:(NSString*)operation valParam:(NSDictionary *)valDict
{    
    [self.programStack addObject:operation]; 
    return [RpnBrain runProgram:self.program usingVariableValues:valDict]; 
}

/** Instance method: performOperation 
 * ------------------------------------
 * performOperation takes a NSDictionary of variable/value pairs and returns 
 * the value of the program currently stored in the _programStack.
 */ 

- (double)performOperation:(NSDictionary *)valDict
{
    return [RpnBrain runProgram:self.program usingVariableValues:valDict]; 
}


/** Instance method: isTwoOperand 
 * ------------------------------
 * isTwoOperand takes an NSString and returns true if the string is in the set
 * of operands that require two operands, false otherwise
 */ 

+ (BOOL)isTwoOperand:(NSString *)operation
{ 
    NSSet *operationSet = [NSSet setWithObjects:@"*", @"/", @"+", @"-", nil]; 
    return [operationSet containsObject:operation]; 
}


/** Instance method: isOneOperand 
 * ------------------------------
 * isOneOperand takes an NSString and returns true if the string is in the set
 * of operands that require one operands, false otherwise
 */ 

+ (BOOL)isOneOperand:(NSString *)operation
{ 
    NSSet *operationSet = [NSSet setWithObjects:@"sqrt", @"sin", @"cos", nil]; 
    return [operationSet containsObject:operation]; 
}

/** Instance method: isNoOperand 
 * ------------------------------
 * isNoOperand takes an NSString and returns true if the string is in the set
 * of operands that require no operands, false otherwise
 */ 

+ (BOOL)isNoOperand:(NSString *)operation
{ 
    NSSet *operationSet = [NSSet setWithObjects:@"π", nil]; 
    return [operationSet containsObject:operation]; 
}

/** Instance method: isOperation 
 * -----------------------------
 * isVariable takes an NSString and returns true if the string is in the set
 * of variables, false otherwise
 */

+ (BOOL)isOperation:(NSString*)operation
{
    NSSet *varSet = [NSSet setWithObjects:@"*","/",@"+",@"-",@"sin",@"cos",@"sqrt", nil]; 
    return [varSet containsObject:operation]; 
}

/** Instance method: isVariable 
 * ------------------------------
 * isVariable takes an NSString and returns true if the string is in the set
 * of variables, false otherwise
 */ 

+ (BOOL)isVariable:(NSString*)operation
{
    NSSet *varSet = [NSSet setWithObjects:@"x",@"a",@"b", nil]; 
    return [varSet containsObject:operation]; 
}

/** Instance method: program
 * -------------------------
 * program returns a copy of the programStack
 */ 
- (id) program { 
    return [self.programStack copy]; 
}

/** Class method: descriptionOfTopOfStack 
 * --------------------------------------
 * descriptionOfTopOfStack takes a program and returns an NSString 
 * description of the program on the top of the stack. descriptionOfTopOfStack 
 * recursively evaluates the program on the top of the stack. 
 *
 * If we have a complete program, then we return the result. If the program
 * is incomplete we recursively evaluate the sub expressions.
 */ 

+ (NSString *)descriptionOfTopOfStack:(id)program 
{
    NSString *result = @""; 

    // defensive: validate there is 1 object before calling removeLastObject
    id topOfStack = [program lastObject]; 
    if(topOfStack) [program removeLastObject];
    
    if([self isTwoOperand:topOfStack])
    {   
        NSAssert( [program count] > 1, @"program should have at least 2 operands");
        // recur with the mutated stack (i.e. we've already popped the last object)
        NSString *backInDisplay = [self descriptionOfTopOfStack:program]; 
        result = [NSString stringWithFormat:@"(%@ %@ %@)",[self descriptionOfTopOfStack:program], 
                                                           topOfStack, 
                                                           backInDisplay]; 
    } 
    else if([self isOneOperand:topOfStack])
    { 
        if(!([program count] > 0)) 
        {
            result = @"ERROR: program should have at least 1 operand"; 
        } else 
        {
            result = [NSString stringWithFormat:@"%@(%@)",topOfStack, [self descriptionOfTopOfStack:program]];
        }
    }  
    else if([self isNoOperand:topOfStack]){ 
        result = [NSString stringWithFormat:@"%@",topOfStack];
    } 
    else if([topOfStack isKindOfClass:[NSNumber class]])
    { 
        result = [NSString stringWithFormat:@"%@", topOfStack]; 
    }
    else if([self isVariable:topOfStack]){ 
        result = topOfStack; 
    }
        
    return result; 
   
}

/** Class method: descriptionOfProgram 
 * -----------------------------------
 * descriptionOfProgram takes a program and returns an NSString representation of the program.
 * The program is represented by an NSArray. 
 * 
 * It can be the case that there are multiple programs on the stack. In that case we build up an 
 * NSString with all programs separated by a comma. 
 * 
 * descriptionOfProgram call its recursive helper function descriptionOfTopOfStack to recursively
 * evaluate a program
 */ 

+ (NSString *)descriptionOfProgram:(id)program
{
    NSMutableArray *stack;
    if ([program isKindOfClass:[NSArray class]]) { 
        stack = [program mutableCopy]; 
    }
    
    NSString *result; 
    result = [self descriptionOfTopOfStack:stack];  
    while([stack count] > 0){ 
        result = [NSString stringWithFormat:@"%@, %@", result, [self descriptionOfTopOfStack:stack]]; 
    }
    return result; 
}



/** Instance method: clearProgramStack 
 * -----------------------------------
 * self-documenting
 */
-(void) clearProgramStack 
{
    [self.programStack removeAllObjects]; 
}

/** Class method: popTopOffStack
 * -----------------------------
 * popTopOffStack gets the top of the stack and returns the appropriate 
 * value. 
 * 
 * Implementation note: This is a class method and the self in [self popOperandOffStack:stack]
 * is the class
 */ 

+ (double)popTopOffStack:(NSMutableArray*)stack
{
    /** Implemenation note: we use an id type for topOfStack because the item could 
     *  be number or string (*,/,+ ...). We use introspection to handle the object
     *  appropriately
     */ 
    
    
    double result = 0; 
    
    id topOfStack = [stack lastObject];     //.1
    if(topOfStack) [stack removeLastObject]; 
    
    if([topOfStack isKindOfClass:[NSNumber class]])
    { 
        result = [topOfStack doubleValue]; 
    }
    else if ([topOfStack isKindOfClass:[NSString class]])
    { 
        NSString *operation = topOfStack; 
        
        if([operation isEqualToString:@"*"])  
        { 
            result = [self popTopOffStack:stack] * [self popTopOffStack:stack]; 
        }
        else if([operation isEqualToString:@"+"])  
        { 
            result = [self popTopOffStack:stack] + [self popTopOffStack:stack]; 
        }
        else if([operation isEqualToString:@"-"])  
        { 
            result = [self popTopOffStack:stack] - [self popTopOffStack:stack]; 
        }
        else if ([operation isEqualToString:@"/"]) 
        {
            double divisor = [self popTopOffStack:stack]; 
            if(divisor) result = [self popTopOffStack:stack] / divisor; 
        } 
        else if([operation isEqualToString:@"sqrt"])  
        { 
            result = sqrt([self popTopOffStack:stack]); 
        }

        else if([operation isEqualToString:@"π"])  
        { 
            result = M_PI; 
        }
        else if([operation isEqualToString:@"cos"])  
        { 
            result = cos([self popTopOffStack:stack]); 
        }
        else if([operation isEqualToString:@"sin"])  
        { 
            result = sin([self popTopOffStack:stack]); 
        }
        else if([operation isEqualToString:@"+/-"])  
        { 
            result = -[self popTopOffStack:stack]; 
        }
        else if([operation isEqualToString:@"C"])  
        { 
            result = 0; 
            [stack removeAllObjects]; 
        }
        
    }
    
    return result; 

}


/** Class method: runProgram 
 * -------------------------
 * runProgram takes a program as input and returns a double. The program is represented by 
 * an NSArry. runProgram calls popTopOffStack to do the recursive evaluation of the program
 */

+ (double)runProgram:(id)program 
{
    /** Implemenation nots:
     * 1. in iOS3 has to say NSMutableArray *stack = nil
     * 2. stack is NSMutableArray, mutableCopy is id
     *    ok to assign id to NSMutableArray
     * 3. need a class method (because method call in a class method)
     *    pops top items of stack and returns the items
     */
    
    NSMutableArray *stack;                      //1.autoset to nil
    if([program isKindOfClass:[NSArray class]]){ 
        stack = [program mutableCopy];          //2.
    }
    return [self popTopOffStack:stack];         //3. 
}


/** Class method: runProgram usingVariableValues
 * -------------------------
 * runProgram-usingVariableValues takes a program as input and returns a double. The program is represented by 
 * an NSArry. runProgram-usingVariableValues iterates through each element in program and replaces variable 
 * with their values. runProgram-usingVariableValues then calls popTopOffStack to do the recursive evaluation 
 * of the program
 */


+ (double)runProgram:(id)program usingVariableValues:(NSDictionary *)variableValues
{
    
    NSAssert([program isKindOfClass:[NSArray class]], @"invalid input for runProgram. program must be array"); 
    
    program = [program mutableCopy]; 
    
    //iterate through program and replace variables with values
    int count = [program count]; 
    id currObj; 
    for (int i = 0; i < count; i++){ 
        currObj = [program objectAtIndex:i]; 
        if([self isVariable:currObj]){ 
            if([variableValues objectForKey:currObj]) {  
                [program replaceObjectAtIndex:i withObject:[variableValues objectForKey:currObj]]; 
            } else { 
                [program replaceObjectAtIndex:i withObject:[NSNumber numberWithDouble:0]]; 
            }
        }
    }
    
    return [self runProgram: program]; 
}

/** Class method: variablesUsedInProgram
 * -------------------------------------
 * Deprecated
 * variablesUsedInProgram takes a program and returns the variable used in the program. 
 * variablesUsedInProgram was needed for one of the requirements for assignement 2 
 * (displaying the variable values). 
 *
 */
     
+ (NSSet *)variablesUsedInProgram:(id) program
{ 
    NSMutableSet *result = [[NSMutableSet alloc] initWithCapacity:3]; 
    if([program isKindOfClass:[NSArray class]]) {
        for(id obj in program) {
            if([obj isKindOfClass:[NSString class]]){ 
                if([RpnBrain isVariable:obj]){ 
                    [result addObject:obj]; 
                }
            }
        }
    }
    if([result count] > 0){ 
        return result; 
    } else { 
        return nil; 
    }
}
         
@end
